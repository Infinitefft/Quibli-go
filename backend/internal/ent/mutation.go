// Code generated by ent, DO NOT EDIT.

package ent

import (
	"backend/internal/ent/comment"
	"backend/internal/ent/follow"
	"backend/internal/ent/post"
	"backend/internal/ent/posttag"
	"backend/internal/ent/predicate"
	"backend/internal/ent/question"
	"backend/internal/ent/questiontag"
	"backend/internal/ent/tag"
	"backend/internal/ent/user"
	"backend/internal/ent/userfavoritepost"
	"backend/internal/ent/userfavoritequestion"
	"backend/internal/ent/userlikepost"
	"backend/internal/ent/userlikequestion"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeComment              = "Comment"
	TypeFollow               = "Follow"
	TypePost                 = "Post"
	TypePostTag              = "PostTag"
	TypeQuestion             = "Question"
	TypeQuestionTag          = "QuestionTag"
	TypeTag                  = "Tag"
	TypeUser                 = "User"
	TypeUserFavoritePost     = "UserFavoritePost"
	TypeUserFavoriteQuestion = "UserFavoriteQuestion"
	TypeUserLikePost         = "UserLikePost"
	TypeUserLikeQuestion     = "UserLikeQuestion"
)

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	content         *string
	user_id         *int
	adduser_id      *int
	post_id         *int
	addpost_id      *int
	question_id     *int
	addquestion_id  *int
	parent_id       *int
	addparent_id    *int
	clearedFields   map[string]struct{}
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	post            map[int]struct{}
	removedpost     map[int]struct{}
	clearedpost     bool
	question        map[int]struct{}
	removedquestion map[int]struct{}
	clearedquestion bool
	parent          map[int]struct{}
	removedparent   map[int]struct{}
	clearedparent   bool
	replies         map[int]struct{}
	removedreplies  map[int]struct{}
	clearedreplies  bool
	done            bool
	oldValue        func(context.Context) (*Comment, error)
	predicates      []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CommentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CommentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetContent sets the "content" field.
func (m *CommentMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *CommentMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *CommentMutation) ClearContent() {
	m.content = nil
	m.clearedFields[comment.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *CommentMutation) ContentCleared() bool {
	_, ok := m.clearedFields[comment.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *CommentMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, comment.FieldContent)
}

// SetUserID sets the "user_id" field.
func (m *CommentMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CommentMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *CommentMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CommentMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CommentMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPostID sets the "post_id" field.
func (m *CommentMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *CommentMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *CommentMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *CommentMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostID clears the value of the "post_id" field.
func (m *CommentMutation) ClearPostID() {
	m.post_id = nil
	m.addpost_id = nil
	m.clearedFields[comment.FieldPostID] = struct{}{}
}

// PostIDCleared returns if the "post_id" field was cleared in this mutation.
func (m *CommentMutation) PostIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldPostID]
	return ok
}

// ResetPostID resets all changes to the "post_id" field.
func (m *CommentMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
	delete(m.clearedFields, comment.FieldPostID)
}

// SetQuestionID sets the "question_id" field.
func (m *CommentMutation) SetQuestionID(i int) {
	m.question_id = &i
	m.addquestion_id = nil
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *CommentMutation) QuestionID() (r int, exists bool) {
	v := m.question_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// AddQuestionID adds i to the "question_id" field.
func (m *CommentMutation) AddQuestionID(i int) {
	if m.addquestion_id != nil {
		*m.addquestion_id += i
	} else {
		m.addquestion_id = &i
	}
}

// AddedQuestionID returns the value that was added to the "question_id" field in this mutation.
func (m *CommentMutation) AddedQuestionID() (r int, exists bool) {
	v := m.addquestion_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuestionID clears the value of the "question_id" field.
func (m *CommentMutation) ClearQuestionID() {
	m.question_id = nil
	m.addquestion_id = nil
	m.clearedFields[comment.FieldQuestionID] = struct{}{}
}

// QuestionIDCleared returns if the "question_id" field was cleared in this mutation.
func (m *CommentMutation) QuestionIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldQuestionID]
	return ok
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *CommentMutation) ResetQuestionID() {
	m.question_id = nil
	m.addquestion_id = nil
	delete(m.clearedFields, comment.FieldQuestionID)
}

// SetParentID sets the "parent_id" field.
func (m *CommentMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CommentMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *CommentMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *CommentMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CommentMutation) ClearParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	m.clearedFields[comment.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CommentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[comment.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CommentMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
	delete(m.clearedFields, comment.FieldParentID)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *CommentMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *CommentMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *CommentMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *CommentMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddPostIDs adds the "post" edge to the Post entity by ids.
func (m *CommentMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the Post entity.
func (m *CommentMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *CommentMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the Post entity by IDs.
func (m *CommentMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the Post entity.
func (m *CommentMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *CommentMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *CommentMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// AddQuestionIDs adds the "question" edge to the Question entity by ids.
func (m *CommentMutation) AddQuestionIDs(ids ...int) {
	if m.question == nil {
		m.question = make(map[int]struct{})
	}
	for i := range ids {
		m.question[ids[i]] = struct{}{}
	}
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *CommentMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *CommentMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// RemoveQuestionIDs removes the "question" edge to the Question entity by IDs.
func (m *CommentMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestion == nil {
		m.removedquestion = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question, ids[i])
		m.removedquestion[ids[i]] = struct{}{}
	}
}

// RemovedQuestion returns the removed IDs of the "question" edge to the Question entity.
func (m *CommentMutation) RemovedQuestionIDs() (ids []int) {
	for id := range m.removedquestion {
		ids = append(ids, id)
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
func (m *CommentMutation) QuestionIDs() (ids []int) {
	for id := range m.question {
		ids = append(ids, id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *CommentMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
	m.removedquestion = nil
}

// AddParentIDs adds the "parent" edge to the Comment entity by ids.
func (m *CommentMutation) AddParentIDs(ids ...int) {
	if m.parent == nil {
		m.parent = make(map[int]struct{})
	}
	for i := range ids {
		m.parent[ids[i]] = struct{}{}
	}
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.clearedparent
}

// RemoveParentIDs removes the "parent" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveParentIDs(ids ...int) {
	if m.removedparent == nil {
		m.removedparent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.parent, ids[i])
		m.removedparent[ids[i]] = struct{}{}
	}
}

// RemovedParent returns the removed IDs of the "parent" edge to the Comment entity.
func (m *CommentMutation) RemovedParentIDs() (ids []int) {
	for id := range m.removedparent {
		ids = append(ids, id)
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
func (m *CommentMutation) ParentIDs() (ids []int) {
	for id := range m.parent {
		ids = append(ids, id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
	m.removedparent = nil
}

// AddReplyIDs adds the "replies" edge to the Comment entity by ids.
func (m *CommentMutation) AddReplyIDs(ids ...int) {
	if m.replies == nil {
		m.replies = make(map[int]struct{})
	}
	for i := range ids {
		m.replies[ids[i]] = struct{}{}
	}
}

// ClearReplies clears the "replies" edge to the Comment entity.
func (m *CommentMutation) ClearReplies() {
	m.clearedreplies = true
}

// RepliesCleared reports if the "replies" edge to the Comment entity was cleared.
func (m *CommentMutation) RepliesCleared() bool {
	return m.clearedreplies
}

// RemoveReplyIDs removes the "replies" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveReplyIDs(ids ...int) {
	if m.removedreplies == nil {
		m.removedreplies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.replies, ids[i])
		m.removedreplies[ids[i]] = struct{}{}
	}
}

// RemovedReplies returns the removed IDs of the "replies" edge to the Comment entity.
func (m *CommentMutation) RemovedRepliesIDs() (ids []int) {
	for id := range m.removedreplies {
		ids = append(ids, id)
	}
	return
}

// RepliesIDs returns the "replies" edge IDs in the mutation.
func (m *CommentMutation) RepliesIDs() (ids []int) {
	for id := range m.replies {
		ids = append(ids, id)
	}
	return
}

// ResetReplies resets all changes to the "replies" edge.
func (m *CommentMutation) ResetReplies() {
	m.replies = nil
	m.clearedreplies = false
	m.removedreplies = nil
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.content != nil {
		fields = append(fields, comment.FieldContent)
	}
	if m.user_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.post_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.question_id != nil {
		fields = append(fields, comment.FieldQuestionID)
	}
	if m.parent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.CreateTime()
	case comment.FieldUpdateTime:
		return m.UpdateTime()
	case comment.FieldContent:
		return m.Content()
	case comment.FieldUserID:
		return m.UserID()
	case comment.FieldPostID:
		return m.PostID()
	case comment.FieldQuestionID:
		return m.QuestionID()
	case comment.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comment.FieldContent:
		return m.OldContent(ctx)
	case comment.FieldUserID:
		return m.OldUserID(ctx)
	case comment.FieldPostID:
		return m.OldPostID(ctx)
	case comment.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case comment.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comment.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case comment.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, comment.FieldUserID)
	}
	if m.addpost_id != nil {
		fields = append(fields, comment.FieldPostID)
	}
	if m.addquestion_id != nil {
		fields = append(fields, comment.FieldQuestionID)
	}
	if m.addparent_id != nil {
		fields = append(fields, comment.FieldParentID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldUserID:
		return m.AddedUserID()
	case comment.FieldPostID:
		return m.AddedPostID()
	case comment.FieldQuestionID:
		return m.AddedQuestionID()
	case comment.FieldParentID:
		return m.AddedParentID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case comment.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case comment.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	case comment.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionID(v)
		return nil
	case comment.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(comment.FieldContent) {
		fields = append(fields, comment.FieldContent)
	}
	if m.FieldCleared(comment.FieldPostID) {
		fields = append(fields, comment.FieldPostID)
	}
	if m.FieldCleared(comment.FieldQuestionID) {
		fields = append(fields, comment.FieldQuestionID)
	}
	if m.FieldCleared(comment.FieldParentID) {
		fields = append(fields, comment.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	switch name {
	case comment.FieldContent:
		m.ClearContent()
		return nil
	case comment.FieldPostID:
		m.ClearPostID()
		return nil
	case comment.FieldQuestionID:
		m.ClearQuestionID()
		return nil
	case comment.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comment.FieldContent:
		m.ResetContent()
		return nil
	case comment.FieldUserID:
		m.ResetUserID()
		return nil
	case comment.FieldPostID:
		m.ResetPostID()
		return nil
	case comment.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case comment.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, comment.EdgePost)
	}
	if m.question != nil {
		edges = append(edges, comment.EdgeQuestion)
	}
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.replies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.question))
		for id := range m.question {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.parent))
		for id := range m.parent {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.replies))
		for id := range m.replies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.removedpost != nil {
		edges = append(edges, comment.EdgePost)
	}
	if m.removedquestion != nil {
		edges = append(edges, comment.EdgeQuestion)
	}
	if m.removedparent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.removedreplies != nil {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.removedquestion))
		for id := range m.removedquestion {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeParent:
		ids := make([]ent.Value, 0, len(m.removedparent))
		for id := range m.removedparent {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeReplies:
		ids := make([]ent.Value, 0, len(m.removedreplies))
		for id := range m.removedreplies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, comment.EdgePost)
	}
	if m.clearedquestion {
		edges = append(edges, comment.EdgeQuestion)
	}
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedreplies {
		edges = append(edges, comment.EdgeReplies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgePost:
		return m.clearedpost
	case comment.EdgeQuestion:
		return m.clearedquestion
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeReplies:
		return m.clearedreplies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgePost:
		m.ResetPost()
		return nil
	case comment.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeReplies:
		m.ResetReplies()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// FollowMutation represents an operation that mutates the Follow nodes in the graph.
type FollowMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	follower_id      *int
	addfollower_id   *int
	following_id     *int
	addfollowing_id  *int
	clearedFields    map[string]struct{}
	follower         map[int]struct{}
	removedfollower  map[int]struct{}
	clearedfollower  bool
	following        map[int]struct{}
	removedfollowing map[int]struct{}
	clearedfollowing bool
	done             bool
	oldValue         func(context.Context) (*Follow, error)
	predicates       []predicate.Follow
}

var _ ent.Mutation = (*FollowMutation)(nil)

// followOption allows management of the mutation configuration using functional options.
type followOption func(*FollowMutation)

// newFollowMutation creates new mutation for the Follow entity.
func newFollowMutation(c config, op Op, opts ...followOption) *FollowMutation {
	m := &FollowMutation{
		config:        c,
		op:            op,
		typ:           TypeFollow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFollowID sets the ID field of the mutation.
func withFollowID(id int) followOption {
	return func(m *FollowMutation) {
		var (
			err   error
			once  sync.Once
			value *Follow
		)
		m.oldValue = func(ctx context.Context) (*Follow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Follow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFollow sets the old Follow of the mutation.
func withFollow(node *Follow) followOption {
	return func(m *FollowMutation) {
		m.oldValue = func(context.Context) (*Follow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FollowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FollowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FollowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FollowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Follow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FollowMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FollowMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FollowMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FollowMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FollowMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FollowMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFollowerID sets the "follower_id" field.
func (m *FollowMutation) SetFollowerID(i int) {
	m.follower_id = &i
	m.addfollower_id = nil
}

// FollowerID returns the value of the "follower_id" field in the mutation.
func (m *FollowMutation) FollowerID() (r int, exists bool) {
	v := m.follower_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowerID returns the old "follower_id" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldFollowerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowerID: %w", err)
	}
	return oldValue.FollowerID, nil
}

// AddFollowerID adds i to the "follower_id" field.
func (m *FollowMutation) AddFollowerID(i int) {
	if m.addfollower_id != nil {
		*m.addfollower_id += i
	} else {
		m.addfollower_id = &i
	}
}

// AddedFollowerID returns the value that was added to the "follower_id" field in this mutation.
func (m *FollowMutation) AddedFollowerID() (r int, exists bool) {
	v := m.addfollower_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowerID resets all changes to the "follower_id" field.
func (m *FollowMutation) ResetFollowerID() {
	m.follower_id = nil
	m.addfollower_id = nil
}

// SetFollowingID sets the "following_id" field.
func (m *FollowMutation) SetFollowingID(i int) {
	m.following_id = &i
	m.addfollowing_id = nil
}

// FollowingID returns the value of the "following_id" field in the mutation.
func (m *FollowMutation) FollowingID() (r int, exists bool) {
	v := m.following_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFollowingID returns the old "following_id" field's value of the Follow entity.
// If the Follow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FollowMutation) OldFollowingID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFollowingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFollowingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFollowingID: %w", err)
	}
	return oldValue.FollowingID, nil
}

// AddFollowingID adds i to the "following_id" field.
func (m *FollowMutation) AddFollowingID(i int) {
	if m.addfollowing_id != nil {
		*m.addfollowing_id += i
	} else {
		m.addfollowing_id = &i
	}
}

// AddedFollowingID returns the value that was added to the "following_id" field in this mutation.
func (m *FollowMutation) AddedFollowingID() (r int, exists bool) {
	v := m.addfollowing_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFollowingID resets all changes to the "following_id" field.
func (m *FollowMutation) ResetFollowingID() {
	m.following_id = nil
	m.addfollowing_id = nil
}

// AddFollowerIDs adds the "follower" edge to the User entity by ids.
func (m *FollowMutation) AddFollowerIDs(ids ...int) {
	if m.follower == nil {
		m.follower = make(map[int]struct{})
	}
	for i := range ids {
		m.follower[ids[i]] = struct{}{}
	}
}

// ClearFollower clears the "follower" edge to the User entity.
func (m *FollowMutation) ClearFollower() {
	m.clearedfollower = true
}

// FollowerCleared reports if the "follower" edge to the User entity was cleared.
func (m *FollowMutation) FollowerCleared() bool {
	return m.clearedfollower
}

// RemoveFollowerIDs removes the "follower" edge to the User entity by IDs.
func (m *FollowMutation) RemoveFollowerIDs(ids ...int) {
	if m.removedfollower == nil {
		m.removedfollower = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.follower, ids[i])
		m.removedfollower[ids[i]] = struct{}{}
	}
}

// RemovedFollower returns the removed IDs of the "follower" edge to the User entity.
func (m *FollowMutation) RemovedFollowerIDs() (ids []int) {
	for id := range m.removedfollower {
		ids = append(ids, id)
	}
	return
}

// FollowerIDs returns the "follower" edge IDs in the mutation.
func (m *FollowMutation) FollowerIDs() (ids []int) {
	for id := range m.follower {
		ids = append(ids, id)
	}
	return
}

// ResetFollower resets all changes to the "follower" edge.
func (m *FollowMutation) ResetFollower() {
	m.follower = nil
	m.clearedfollower = false
	m.removedfollower = nil
}

// AddFollowingIDs adds the "following" edge to the User entity by ids.
func (m *FollowMutation) AddFollowingIDs(ids ...int) {
	if m.following == nil {
		m.following = make(map[int]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the User entity.
func (m *FollowMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the User entity was cleared.
func (m *FollowMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the User entity by IDs.
func (m *FollowMutation) RemoveFollowingIDs(ids ...int) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the User entity.
func (m *FollowMutation) RemovedFollowingIDs() (ids []int) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *FollowMutation) FollowingIDs() (ids []int) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *FollowMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// Where appends a list predicates to the FollowMutation builder.
func (m *FollowMutation) Where(ps ...predicate.Follow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FollowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FollowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Follow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FollowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FollowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Follow).
func (m *FollowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FollowMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, follow.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, follow.FieldUpdateTime)
	}
	if m.follower_id != nil {
		fields = append(fields, follow.FieldFollowerID)
	}
	if m.following_id != nil {
		fields = append(fields, follow.FieldFollowingID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FollowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case follow.FieldCreateTime:
		return m.CreateTime()
	case follow.FieldUpdateTime:
		return m.UpdateTime()
	case follow.FieldFollowerID:
		return m.FollowerID()
	case follow.FieldFollowingID:
		return m.FollowingID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FollowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case follow.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case follow.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case follow.FieldFollowerID:
		return m.OldFollowerID(ctx)
	case follow.FieldFollowingID:
		return m.OldFollowingID(ctx)
	}
	return nil, fmt.Errorf("unknown Follow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case follow.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case follow.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case follow.FieldFollowerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowerID(v)
		return nil
	case follow.FieldFollowingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFollowingID(v)
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FollowMutation) AddedFields() []string {
	var fields []string
	if m.addfollower_id != nil {
		fields = append(fields, follow.FieldFollowerID)
	}
	if m.addfollowing_id != nil {
		fields = append(fields, follow.FieldFollowingID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FollowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case follow.FieldFollowerID:
		return m.AddedFollowerID()
	case follow.FieldFollowingID:
		return m.AddedFollowingID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FollowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case follow.FieldFollowerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowerID(v)
		return nil
	case follow.FieldFollowingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFollowingID(v)
		return nil
	}
	return fmt.Errorf("unknown Follow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FollowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FollowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FollowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Follow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FollowMutation) ResetField(name string) error {
	switch name {
	case follow.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case follow.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case follow.FieldFollowerID:
		m.ResetFollowerID()
		return nil
	case follow.FieldFollowingID:
		m.ResetFollowingID()
		return nil
	}
	return fmt.Errorf("unknown Follow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FollowMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.follower != nil {
		edges = append(edges, follow.EdgeFollower)
	}
	if m.following != nil {
		edges = append(edges, follow.EdgeFollowing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FollowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case follow.EdgeFollower:
		ids := make([]ent.Value, 0, len(m.follower))
		for id := range m.follower {
			ids = append(ids, id)
		}
		return ids
	case follow.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FollowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfollower != nil {
		edges = append(edges, follow.EdgeFollower)
	}
	if m.removedfollowing != nil {
		edges = append(edges, follow.EdgeFollowing)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FollowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case follow.EdgeFollower:
		ids := make([]ent.Value, 0, len(m.removedfollower))
		for id := range m.removedfollower {
			ids = append(ids, id)
		}
		return ids
	case follow.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FollowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfollower {
		edges = append(edges, follow.EdgeFollower)
	}
	if m.clearedfollowing {
		edges = append(edges, follow.EdgeFollowing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FollowMutation) EdgeCleared(name string) bool {
	switch name {
	case follow.EdgeFollower:
		return m.clearedfollower
	case follow.EdgeFollowing:
		return m.clearedfollowing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FollowMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Follow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FollowMutation) ResetEdge(name string) error {
	switch name {
	case follow.EdgeFollower:
		m.ResetFollower()
		return nil
	case follow.EdgeFollowing:
		m.ResetFollowing()
		return nil
	}
	return fmt.Errorf("unknown Follow edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	title            *string
	content          *string
	embedding        *[]byte
	clearedFields    map[string]struct{}
	user             map[int]struct{}
	removeduser      map[int]struct{}
	cleareduser      bool
	comments         map[int]struct{}
	removedcomments  map[int]struct{}
	clearedcomments  bool
	tags             map[int]struct{}
	removedtags      map[int]struct{}
	clearedtags      bool
	likes            map[int]struct{}
	removedlikes     map[int]struct{}
	clearedlikes     bool
	favorites        map[int]struct{}
	removedfavorites map[int]struct{}
	clearedfavorites bool
	done             bool
	oldValue         func(context.Context) (*Post, error)
	predicates       []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PostMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PostMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PostMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PostMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PostMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PostMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PostMutation) ClearContent() {
	m.content = nil
	m.clearedFields[post.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PostMutation) ContentCleared() bool {
	_, ok := m.clearedFields[post.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, post.FieldContent)
}

// SetEmbedding sets the "embedding" field.
func (m *PostMutation) SetEmbedding(b []byte) {
	m.embedding = &b
}

// Embedding returns the value of the "embedding" field in the mutation.
func (m *PostMutation) Embedding() (r []byte, exists bool) {
	v := m.embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbedding returns the old "embedding" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldEmbedding(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbedding: %w", err)
	}
	return oldValue.Embedding, nil
}

// ClearEmbedding clears the value of the "embedding" field.
func (m *PostMutation) ClearEmbedding() {
	m.embedding = nil
	m.clearedFields[post.FieldEmbedding] = struct{}{}
}

// EmbeddingCleared returns if the "embedding" field was cleared in this mutation.
func (m *PostMutation) EmbeddingCleared() bool {
	_, ok := m.clearedFields[post.FieldEmbedding]
	return ok
}

// ResetEmbedding resets all changes to the "embedding" field.
func (m *PostMutation) ResetEmbedding() {
	m.embedding = nil
	delete(m.clearedFields, post.FieldEmbedding)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *PostMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *PostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PostMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *PostMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *PostMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *PostMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *PostMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *PostMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *PostMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *PostMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *PostMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *PostMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *PostMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the PostTag entity by ids.
func (m *PostMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the PostTag entity.
func (m *PostMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the PostTag entity was cleared.
func (m *PostMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the PostTag entity by IDs.
func (m *PostMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the PostTag entity.
func (m *PostMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *PostMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *PostMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLikeIDs adds the "likes" edge to the UserLikePost entity by ids.
func (m *PostMutation) AddLikeIDs(ids ...int) {
	if m.likes == nil {
		m.likes = make(map[int]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the UserLikePost entity.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the UserLikePost entity was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the UserLikePost entity by IDs.
func (m *PostMutation) RemoveLikeIDs(ids ...int) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the UserLikePost entity.
func (m *PostMutation) RemovedLikesIDs() (ids []int) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *PostMutation) LikesIDs() (ids []int) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddFavoriteIDs adds the "favorites" edge to the UserFavoritePost entity by ids.
func (m *PostMutation) AddFavoriteIDs(ids ...int) {
	if m.favorites == nil {
		m.favorites = make(map[int]struct{})
	}
	for i := range ids {
		m.favorites[ids[i]] = struct{}{}
	}
}

// ClearFavorites clears the "favorites" edge to the UserFavoritePost entity.
func (m *PostMutation) ClearFavorites() {
	m.clearedfavorites = true
}

// FavoritesCleared reports if the "favorites" edge to the UserFavoritePost entity was cleared.
func (m *PostMutation) FavoritesCleared() bool {
	return m.clearedfavorites
}

// RemoveFavoriteIDs removes the "favorites" edge to the UserFavoritePost entity by IDs.
func (m *PostMutation) RemoveFavoriteIDs(ids ...int) {
	if m.removedfavorites == nil {
		m.removedfavorites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorites, ids[i])
		m.removedfavorites[ids[i]] = struct{}{}
	}
}

// RemovedFavorites returns the removed IDs of the "favorites" edge to the UserFavoritePost entity.
func (m *PostMutation) RemovedFavoritesIDs() (ids []int) {
	for id := range m.removedfavorites {
		ids = append(ids, id)
	}
	return
}

// FavoritesIDs returns the "favorites" edge IDs in the mutation.
func (m *PostMutation) FavoritesIDs() (ids []int) {
	for id := range m.favorites {
		ids = append(ids, id)
	}
	return
}

// ResetFavorites resets all changes to the "favorites" edge.
func (m *PostMutation) ResetFavorites() {
	m.favorites = nil
	m.clearedfavorites = false
	m.removedfavorites = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, post.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, post.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.embedding != nil {
		fields = append(fields, post.FieldEmbedding)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreateTime:
		return m.CreateTime()
	case post.FieldUpdateTime:
		return m.UpdateTime()
	case post.FieldTitle:
		return m.Title()
	case post.FieldContent:
		return m.Content()
	case post.FieldEmbedding:
		return m.Embedding()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case post.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case post.FieldTitle:
		return m.OldTitle(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldEmbedding:
		return m.OldEmbedding(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case post.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldEmbedding:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbedding(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldContent) {
		fields = append(fields, post.FieldContent)
	}
	if m.FieldCleared(post.FieldEmbedding) {
		fields = append(fields, post.FieldEmbedding)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldContent:
		m.ClearContent()
		return nil
	case post.FieldEmbedding:
		m.ClearEmbedding()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case post.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldEmbedding:
		m.ResetEmbedding()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, post.EdgeUser)
	}
	if m.comments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.favorites != nil {
		edges = append(edges, post.EdgeFavorites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.favorites))
		for id := range m.favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser != nil {
		edges = append(edges, post.EdgeUser)
	}
	if m.removedcomments != nil {
		edges = append(edges, post.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, post.EdgeTags)
	}
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	if m.removedfavorites != nil {
		edges = append(edges, post.EdgeFavorites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case post.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.removedfavorites))
		for id := range m.removedfavorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, post.EdgeUser)
	}
	if m.clearedcomments {
		edges = append(edges, post.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, post.EdgeTags)
	}
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	if m.clearedfavorites {
		edges = append(edges, post.EdgeFavorites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeUser:
		return m.cleareduser
	case post.EdgeComments:
		return m.clearedcomments
	case post.EdgeTags:
		return m.clearedtags
	case post.EdgeLikes:
		return m.clearedlikes
	case post.EdgeFavorites:
		return m.clearedfavorites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeUser:
		m.ResetUser()
		return nil
	case post.EdgeComments:
		m.ResetComments()
		return nil
	case post.EdgeTags:
		m.ResetTags()
		return nil
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	case post.EdgeFavorites:
		m.ResetFavorites()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostTagMutation represents an operation that mutates the PostTag nodes in the graph.
type PostTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	post_id       *int
	addpost_id    *int
	tag_id        *int
	addtag_id     *int
	clearedFields map[string]struct{}
	post          map[int]struct{}
	removedpost   map[int]struct{}
	clearedpost   bool
	tag           map[int]struct{}
	removedtag    map[int]struct{}
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*PostTag, error)
	predicates    []predicate.PostTag
}

var _ ent.Mutation = (*PostTagMutation)(nil)

// posttagOption allows management of the mutation configuration using functional options.
type posttagOption func(*PostTagMutation)

// newPostTagMutation creates new mutation for the PostTag entity.
func newPostTagMutation(c config, op Op, opts ...posttagOption) *PostTagMutation {
	m := &PostTagMutation{
		config:        c,
		op:            op,
		typ:           TypePostTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTagID sets the ID field of the mutation.
func withPostTagID(id int) posttagOption {
	return func(m *PostTagMutation) {
		var (
			err   error
			once  sync.Once
			value *PostTag
		)
		m.oldValue = func(ctx context.Context) (*PostTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostTag sets the old PostTag of the mutation.
func withPostTag(node *PostTag) posttagOption {
	return func(m *PostTagMutation) {
		m.oldValue = func(context.Context) (*PostTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPostID sets the "post_id" field.
func (m *PostTagMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *PostTagMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *PostTagMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *PostTagMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *PostTagMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
}

// SetTagID sets the "tag_id" field.
func (m *PostTagMutation) SetTagID(i int) {
	m.tag_id = &i
	m.addtag_id = nil
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *PostTagMutation) TagID() (r int, exists bool) {
	v := m.tag_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldTagID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// AddTagID adds i to the "tag_id" field.
func (m *PostTagMutation) AddTagID(i int) {
	if m.addtag_id != nil {
		*m.addtag_id += i
	} else {
		m.addtag_id = &i
	}
}

// AddedTagID returns the value that was added to the "tag_id" field in this mutation.
func (m *PostTagMutation) AddedTagID() (r int, exists bool) {
	v := m.addtag_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *PostTagMutation) ResetTagID() {
	m.tag_id = nil
	m.addtag_id = nil
}

// AddPostIDs adds the "post" edge to the Post entity by ids.
func (m *PostTagMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the Post entity.
func (m *PostTagMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *PostTagMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the Post entity by IDs.
func (m *PostTagMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the Post entity.
func (m *PostTagMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *PostTagMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *PostTagMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *PostTagMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *PostTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *PostTagMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *PostTagMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *PostTagMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *PostTagMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *PostTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Where appends a list predicates to the PostTagMutation builder.
func (m *PostTagMutation) Where(ps ...predicate.PostTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostTag).
func (m *PostTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.post_id != nil {
		fields = append(fields, posttag.FieldPostID)
	}
	if m.tag_id != nil {
		fields = append(fields, posttag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldPostID:
		return m.PostID()
	case posttag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttag.FieldPostID:
		return m.OldPostID(ctx)
	case posttag.FieldTagID:
		return m.OldTagID(ctx)
	}
	return nil, fmt.Errorf("unknown PostTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	case posttag.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTagMutation) AddedFields() []string {
	var fields []string
	if m.addpost_id != nil {
		fields = append(fields, posttag.FieldPostID)
	}
	if m.addtag_id != nil {
		fields = append(fields, posttag.FieldTagID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldPostID:
		return m.AddedPostID()
	case posttag.FieldTagID:
		return m.AddedTagID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	case posttag.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTagID(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTagMutation) ResetField(name string) error {
	switch name {
	case posttag.FieldPostID:
		m.ResetPostID()
		return nil
	case posttag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post != nil {
		edges = append(edges, posttag.EdgePost)
	}
	if m.tag != nil {
		edges = append(edges, posttag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	case posttag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpost != nil {
		edges = append(edges, posttag.EdgePost)
	}
	if m.removedtag != nil {
		edges = append(edges, posttag.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	case posttag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost {
		edges = append(edges, posttag.EdgePost)
	}
	if m.clearedtag {
		edges = append(edges, posttag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTagMutation) EdgeCleared(name string) bool {
	switch name {
	case posttag.EdgePost:
		return m.clearedpost
	case posttag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTagMutation) ResetEdge(name string) error {
	switch name {
	case posttag.EdgePost:
		m.ResetPost()
		return nil
	case posttag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown PostTag edge %s", name)
}

// QuestionMutation represents an operation that mutates the Question nodes in the graph.
type QuestionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	title            *string
	embedding        *[]byte
	clearedFields    map[string]struct{}
	user             map[int]struct{}
	removeduser      map[int]struct{}
	cleareduser      bool
	comments         map[int]struct{}
	removedcomments  map[int]struct{}
	clearedcomments  bool
	tags             map[int]struct{}
	removedtags      map[int]struct{}
	clearedtags      bool
	likes            map[int]struct{}
	removedlikes     map[int]struct{}
	clearedlikes     bool
	favorites        map[int]struct{}
	removedfavorites map[int]struct{}
	clearedfavorites bool
	done             bool
	oldValue         func(context.Context) (*Question, error)
	predicates       []predicate.Question
}

var _ ent.Mutation = (*QuestionMutation)(nil)

// questionOption allows management of the mutation configuration using functional options.
type questionOption func(*QuestionMutation)

// newQuestionMutation creates new mutation for the Question entity.
func newQuestionMutation(c config, op Op, opts ...questionOption) *QuestionMutation {
	m := &QuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionID sets the ID field of the mutation.
func withQuestionID(id int) questionOption {
	return func(m *QuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *Question
		)
		m.oldValue = func(ctx context.Context) (*Question, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Question.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestion sets the old Question of the mutation.
func withQuestion(node *Question) questionOption {
	return func(m *QuestionMutation) {
		m.oldValue = func(context.Context) (*Question, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Question.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *QuestionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *QuestionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *QuestionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *QuestionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *QuestionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *QuestionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *QuestionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *QuestionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *QuestionMutation) ResetTitle() {
	m.title = nil
}

// SetEmbedding sets the "embedding" field.
func (m *QuestionMutation) SetEmbedding(b []byte) {
	m.embedding = &b
}

// Embedding returns the value of the "embedding" field in the mutation.
func (m *QuestionMutation) Embedding() (r []byte, exists bool) {
	v := m.embedding
	if v == nil {
		return
	}
	return *v, true
}

// OldEmbedding returns the old "embedding" field's value of the Question entity.
// If the Question object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionMutation) OldEmbedding(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmbedding is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmbedding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmbedding: %w", err)
	}
	return oldValue.Embedding, nil
}

// ClearEmbedding clears the value of the "embedding" field.
func (m *QuestionMutation) ClearEmbedding() {
	m.embedding = nil
	m.clearedFields[question.FieldEmbedding] = struct{}{}
}

// EmbeddingCleared returns if the "embedding" field was cleared in this mutation.
func (m *QuestionMutation) EmbeddingCleared() bool {
	_, ok := m.clearedFields[question.FieldEmbedding]
	return ok
}

// ResetEmbedding resets all changes to the "embedding" field.
func (m *QuestionMutation) ResetEmbedding() {
	m.embedding = nil
	delete(m.clearedFields, question.FieldEmbedding)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *QuestionMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *QuestionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *QuestionMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *QuestionMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *QuestionMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *QuestionMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *QuestionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *QuestionMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *QuestionMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *QuestionMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *QuestionMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *QuestionMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *QuestionMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *QuestionMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddTagIDs adds the "tags" edge to the QuestionTag entity by ids.
func (m *QuestionMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the QuestionTag entity.
func (m *QuestionMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the QuestionTag entity was cleared.
func (m *QuestionMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the QuestionTag entity by IDs.
func (m *QuestionMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the QuestionTag entity.
func (m *QuestionMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *QuestionMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *QuestionMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddLikeIDs adds the "likes" edge to the UserLikeQuestion entity by ids.
func (m *QuestionMutation) AddLikeIDs(ids ...int) {
	if m.likes == nil {
		m.likes = make(map[int]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the "likes" edge to the UserLikeQuestion entity.
func (m *QuestionMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared reports if the "likes" edge to the UserLikeQuestion entity was cleared.
func (m *QuestionMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the "likes" edge to the UserLikeQuestion entity by IDs.
func (m *QuestionMutation) RemoveLikeIDs(ids ...int) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.likes, ids[i])
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed IDs of the "likes" edge to the UserLikeQuestion entity.
func (m *QuestionMutation) RemovedLikesIDs() (ids []int) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the "likes" edge IDs in the mutation.
func (m *QuestionMutation) LikesIDs() (ids []int) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes resets all changes to the "likes" edge.
func (m *QuestionMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// AddFavoriteIDs adds the "favorites" edge to the UserFavoriteQuestion entity by ids.
func (m *QuestionMutation) AddFavoriteIDs(ids ...int) {
	if m.favorites == nil {
		m.favorites = make(map[int]struct{})
	}
	for i := range ids {
		m.favorites[ids[i]] = struct{}{}
	}
}

// ClearFavorites clears the "favorites" edge to the UserFavoriteQuestion entity.
func (m *QuestionMutation) ClearFavorites() {
	m.clearedfavorites = true
}

// FavoritesCleared reports if the "favorites" edge to the UserFavoriteQuestion entity was cleared.
func (m *QuestionMutation) FavoritesCleared() bool {
	return m.clearedfavorites
}

// RemoveFavoriteIDs removes the "favorites" edge to the UserFavoriteQuestion entity by IDs.
func (m *QuestionMutation) RemoveFavoriteIDs(ids ...int) {
	if m.removedfavorites == nil {
		m.removedfavorites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorites, ids[i])
		m.removedfavorites[ids[i]] = struct{}{}
	}
}

// RemovedFavorites returns the removed IDs of the "favorites" edge to the UserFavoriteQuestion entity.
func (m *QuestionMutation) RemovedFavoritesIDs() (ids []int) {
	for id := range m.removedfavorites {
		ids = append(ids, id)
	}
	return
}

// FavoritesIDs returns the "favorites" edge IDs in the mutation.
func (m *QuestionMutation) FavoritesIDs() (ids []int) {
	for id := range m.favorites {
		ids = append(ids, id)
	}
	return
}

// ResetFavorites resets all changes to the "favorites" edge.
func (m *QuestionMutation) ResetFavorites() {
	m.favorites = nil
	m.clearedfavorites = false
	m.removedfavorites = nil
}

// Where appends a list predicates to the QuestionMutation builder.
func (m *QuestionMutation) Where(ps ...predicate.Question) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Question, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Question).
func (m *QuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, question.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, question.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, question.FieldTitle)
	}
	if m.embedding != nil {
		fields = append(fields, question.FieldEmbedding)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case question.FieldCreateTime:
		return m.CreateTime()
	case question.FieldUpdateTime:
		return m.UpdateTime()
	case question.FieldTitle:
		return m.Title()
	case question.FieldEmbedding:
		return m.Embedding()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case question.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case question.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case question.FieldTitle:
		return m.OldTitle(ctx)
	case question.FieldEmbedding:
		return m.OldEmbedding(ctx)
	}
	return nil, fmt.Errorf("unknown Question field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case question.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case question.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case question.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case question.FieldEmbedding:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmbedding(v)
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Question numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(question.FieldEmbedding) {
		fields = append(fields, question.FieldEmbedding)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionMutation) ClearField(name string) error {
	switch name {
	case question.FieldEmbedding:
		m.ClearEmbedding()
		return nil
	}
	return fmt.Errorf("unknown Question nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionMutation) ResetField(name string) error {
	switch name {
	case question.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case question.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case question.FieldTitle:
		m.ResetTitle()
		return nil
	case question.FieldEmbedding:
		m.ResetEmbedding()
		return nil
	}
	return fmt.Errorf("unknown Question field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, question.EdgeUser)
	}
	if m.comments != nil {
		edges = append(edges, question.EdgeComments)
	}
	if m.tags != nil {
		edges = append(edges, question.EdgeTags)
	}
	if m.likes != nil {
		edges = append(edges, question.EdgeLikes)
	}
	if m.favorites != nil {
		edges = append(edges, question.EdgeFavorites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.favorites))
		for id := range m.favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeduser != nil {
		edges = append(edges, question.EdgeUser)
	}
	if m.removedcomments != nil {
		edges = append(edges, question.EdgeComments)
	}
	if m.removedtags != nil {
		edges = append(edges, question.EdgeTags)
	}
	if m.removedlikes != nil {
		edges = append(edges, question.EdgeLikes)
	}
	if m.removedfavorites != nil {
		edges = append(edges, question.EdgeFavorites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case question.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	case question.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.removedfavorites))
		for id := range m.removedfavorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, question.EdgeUser)
	}
	if m.clearedcomments {
		edges = append(edges, question.EdgeComments)
	}
	if m.clearedtags {
		edges = append(edges, question.EdgeTags)
	}
	if m.clearedlikes {
		edges = append(edges, question.EdgeLikes)
	}
	if m.clearedfavorites {
		edges = append(edges, question.EdgeFavorites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case question.EdgeUser:
		return m.cleareduser
	case question.EdgeComments:
		return m.clearedcomments
	case question.EdgeTags:
		return m.clearedtags
	case question.EdgeLikes:
		return m.clearedlikes
	case question.EdgeFavorites:
		return m.clearedfavorites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Question unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionMutation) ResetEdge(name string) error {
	switch name {
	case question.EdgeUser:
		m.ResetUser()
		return nil
	case question.EdgeComments:
		m.ResetComments()
		return nil
	case question.EdgeTags:
		m.ResetTags()
		return nil
	case question.EdgeLikes:
		m.ResetLikes()
		return nil
	case question.EdgeFavorites:
		m.ResetFavorites()
		return nil
	}
	return fmt.Errorf("unknown Question edge %s", name)
}

// QuestionTagMutation represents an operation that mutates the QuestionTag nodes in the graph.
type QuestionTagMutation struct {
	config
	op              Op
	typ             string
	id              *int
	question_id     *int
	addquestion_id  *int
	tag_id          *int
	addtag_id       *int
	clearedFields   map[string]struct{}
	question        map[int]struct{}
	removedquestion map[int]struct{}
	clearedquestion bool
	tag             map[int]struct{}
	removedtag      map[int]struct{}
	clearedtag      bool
	done            bool
	oldValue        func(context.Context) (*QuestionTag, error)
	predicates      []predicate.QuestionTag
}

var _ ent.Mutation = (*QuestionTagMutation)(nil)

// questiontagOption allows management of the mutation configuration using functional options.
type questiontagOption func(*QuestionTagMutation)

// newQuestionTagMutation creates new mutation for the QuestionTag entity.
func newQuestionTagMutation(c config, op Op, opts ...questiontagOption) *QuestionTagMutation {
	m := &QuestionTagMutation{
		config:        c,
		op:            op,
		typ:           TypeQuestionTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuestionTagID sets the ID field of the mutation.
func withQuestionTagID(id int) questiontagOption {
	return func(m *QuestionTagMutation) {
		var (
			err   error
			once  sync.Once
			value *QuestionTag
		)
		m.oldValue = func(ctx context.Context) (*QuestionTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QuestionTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuestionTag sets the old QuestionTag of the mutation.
func withQuestionTag(node *QuestionTag) questiontagOption {
	return func(m *QuestionTagMutation) {
		m.oldValue = func(context.Context) (*QuestionTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuestionTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuestionTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuestionTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuestionTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QuestionTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuestionID sets the "question_id" field.
func (m *QuestionTagMutation) SetQuestionID(i int) {
	m.question_id = &i
	m.addquestion_id = nil
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *QuestionTagMutation) QuestionID() (r int, exists bool) {
	v := m.question_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the QuestionTag entity.
// If the QuestionTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionTagMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// AddQuestionID adds i to the "question_id" field.
func (m *QuestionTagMutation) AddQuestionID(i int) {
	if m.addquestion_id != nil {
		*m.addquestion_id += i
	} else {
		m.addquestion_id = &i
	}
}

// AddedQuestionID returns the value that was added to the "question_id" field in this mutation.
func (m *QuestionTagMutation) AddedQuestionID() (r int, exists bool) {
	v := m.addquestion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *QuestionTagMutation) ResetQuestionID() {
	m.question_id = nil
	m.addquestion_id = nil
}

// SetTagID sets the "tag_id" field.
func (m *QuestionTagMutation) SetTagID(i int) {
	m.tag_id = &i
	m.addtag_id = nil
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *QuestionTagMutation) TagID() (r int, exists bool) {
	v := m.tag_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the QuestionTag entity.
// If the QuestionTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuestionTagMutation) OldTagID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// AddTagID adds i to the "tag_id" field.
func (m *QuestionTagMutation) AddTagID(i int) {
	if m.addtag_id != nil {
		*m.addtag_id += i
	} else {
		m.addtag_id = &i
	}
}

// AddedTagID returns the value that was added to the "tag_id" field in this mutation.
func (m *QuestionTagMutation) AddedTagID() (r int, exists bool) {
	v := m.addtag_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *QuestionTagMutation) ResetTagID() {
	m.tag_id = nil
	m.addtag_id = nil
}

// AddQuestionIDs adds the "question" edge to the Question entity by ids.
func (m *QuestionTagMutation) AddQuestionIDs(ids ...int) {
	if m.question == nil {
		m.question = make(map[int]struct{})
	}
	for i := range ids {
		m.question[ids[i]] = struct{}{}
	}
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *QuestionTagMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *QuestionTagMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// RemoveQuestionIDs removes the "question" edge to the Question entity by IDs.
func (m *QuestionTagMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestion == nil {
		m.removedquestion = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question, ids[i])
		m.removedquestion[ids[i]] = struct{}{}
	}
}

// RemovedQuestion returns the removed IDs of the "question" edge to the Question entity.
func (m *QuestionTagMutation) RemovedQuestionIDs() (ids []int) {
	for id := range m.removedquestion {
		ids = append(ids, id)
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
func (m *QuestionTagMutation) QuestionIDs() (ids []int) {
	for id := range m.question {
		ids = append(ids, id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *QuestionTagMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
	m.removedquestion = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *QuestionTagMutation) AddTagIDs(ids ...int) {
	if m.tag == nil {
		m.tag = make(map[int]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *QuestionTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *QuestionTagMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *QuestionTagMutation) RemoveTagIDs(ids ...int) {
	if m.removedtag == nil {
		m.removedtag = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *QuestionTagMutation) RemovedTagIDs() (ids []int) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *QuestionTagMutation) TagIDs() (ids []int) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *QuestionTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Where appends a list predicates to the QuestionTagMutation builder.
func (m *QuestionTagMutation) Where(ps ...predicate.QuestionTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QuestionTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QuestionTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QuestionTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QuestionTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QuestionTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QuestionTag).
func (m *QuestionTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuestionTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.question_id != nil {
		fields = append(fields, questiontag.FieldQuestionID)
	}
	if m.tag_id != nil {
		fields = append(fields, questiontag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuestionTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case questiontag.FieldQuestionID:
		return m.QuestionID()
	case questiontag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuestionTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case questiontag.FieldQuestionID:
		return m.OldQuestionID(ctx)
	case questiontag.FieldTagID:
		return m.OldTagID(ctx)
	}
	return nil, fmt.Errorf("unknown QuestionTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case questiontag.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	case questiontag.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuestionTagMutation) AddedFields() []string {
	var fields []string
	if m.addquestion_id != nil {
		fields = append(fields, questiontag.FieldQuestionID)
	}
	if m.addtag_id != nil {
		fields = append(fields, questiontag.FieldTagID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuestionTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case questiontag.FieldQuestionID:
		return m.AddedQuestionID()
	case questiontag.FieldTagID:
		return m.AddedTagID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuestionTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case questiontag.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionID(v)
		return nil
	case questiontag.FieldTagID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTagID(v)
		return nil
	}
	return fmt.Errorf("unknown QuestionTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuestionTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuestionTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuestionTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown QuestionTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuestionTagMutation) ResetField(name string) error {
	switch name {
	case questiontag.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	case questiontag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown QuestionTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuestionTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.question != nil {
		edges = append(edges, questiontag.EdgeQuestion)
	}
	if m.tag != nil {
		edges = append(edges, questiontag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuestionTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case questiontag.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.question))
		for id := range m.question {
			ids = append(ids, id)
		}
		return ids
	case questiontag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuestionTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedquestion != nil {
		edges = append(edges, questiontag.EdgeQuestion)
	}
	if m.removedtag != nil {
		edges = append(edges, questiontag.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuestionTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case questiontag.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.removedquestion))
		for id := range m.removedquestion {
			ids = append(ids, id)
		}
		return ids
	case questiontag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuestionTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedquestion {
		edges = append(edges, questiontag.EdgeQuestion)
	}
	if m.clearedtag {
		edges = append(edges, questiontag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuestionTagMutation) EdgeCleared(name string) bool {
	switch name {
	case questiontag.EdgeQuestion:
		return m.clearedquestion
	case questiontag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuestionTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown QuestionTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuestionTagMutation) ResetEdge(name string) error {
	switch name {
	case questiontag.EdgeQuestion:
		m.ResetQuestion()
		return nil
	case questiontag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown QuestionTag edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	posts            map[int]struct{}
	removedposts     map[int]struct{}
	clearedposts     bool
	questions        map[int]struct{}
	removedquestions map[int]struct{}
	clearedquestions bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddPostIDs adds the "posts" edge to the PostTag entity by ids.
func (m *TagMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the PostTag entity.
func (m *TagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the PostTag entity was cleared.
func (m *TagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the PostTag entity by IDs.
func (m *TagMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the PostTag entity.
func (m *TagMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *TagMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *TagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddQuestionIDs adds the "questions" edge to the QuestionTag entity by ids.
func (m *TagMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the QuestionTag entity.
func (m *TagMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the QuestionTag entity was cleared.
func (m *TagMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the QuestionTag entity by IDs.
func (m *TagMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the QuestionTag entity.
func (m *TagMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *TagMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *TagMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.posts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.questions != nil {
		edges = append(edges, tag.EdgeQuestions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedposts != nil {
		edges = append(edges, tag.EdgePosts)
	}
	if m.removedquestions != nil {
		edges = append(edges, tag.EdgeQuestions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedposts {
		edges = append(edges, tag.EdgePosts)
	}
	if m.clearedquestions {
		edges = append(edges, tag.EdgeQuestions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgePosts:
		return m.clearedposts
	case tag.EdgeQuestions:
		return m.clearedquestions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgePosts:
		m.ResetPosts()
		return nil
	case tag.EdgeQuestions:
		m.ResetQuestions()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	create_time               *time.Time
	update_time               *time.Time
	phone                     *string
	nickname                  *string
	password                  *string
	avatar                    *string
	clearedFields             map[string]struct{}
	posts                     map[int]struct{}
	removedposts              map[int]struct{}
	clearedposts              bool
	questions                 map[int]struct{}
	removedquestions          map[int]struct{}
	clearedquestions          bool
	comments                  map[int]struct{}
	removedcomments           map[int]struct{}
	clearedcomments           bool
	like_posts                map[int]struct{}
	removedlike_posts         map[int]struct{}
	clearedlike_posts         bool
	like_questions            map[int]struct{}
	removedlike_questions     map[int]struct{}
	clearedlike_questions     bool
	favorite_posts            map[int]struct{}
	removedfavorite_posts     map[int]struct{}
	clearedfavorite_posts     bool
	favorite_questions        map[int]struct{}
	removedfavorite_questions map[int]struct{}
	clearedfavorite_questions bool
	following                 map[int]struct{}
	removedfollowing          map[int]struct{}
	clearedfollowing          bool
	followed_by               map[int]struct{}
	removedfollowed_by        map[int]struct{}
	clearedfollowed_by        bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ClearNickname clears the value of the "nickname" field.
func (m *UserMutation) ClearNickname() {
	m.nickname = nil
	m.clearedFields[user.FieldNickname] = struct{}{}
}

// NicknameCleared returns if the "nickname" field was cleared in this mutation.
func (m *UserMutation) NicknameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickname]
	return ok
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
	delete(m.clearedFields, user.FieldNickname)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *UserMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *UserMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *UserMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *UserMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *UserMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *UserMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *UserMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddQuestionIDs adds the "questions" edge to the Question entity by ids.
func (m *UserMutation) AddQuestionIDs(ids ...int) {
	if m.questions == nil {
		m.questions = make(map[int]struct{})
	}
	for i := range ids {
		m.questions[ids[i]] = struct{}{}
	}
}

// ClearQuestions clears the "questions" edge to the Question entity.
func (m *UserMutation) ClearQuestions() {
	m.clearedquestions = true
}

// QuestionsCleared reports if the "questions" edge to the Question entity was cleared.
func (m *UserMutation) QuestionsCleared() bool {
	return m.clearedquestions
}

// RemoveQuestionIDs removes the "questions" edge to the Question entity by IDs.
func (m *UserMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestions == nil {
		m.removedquestions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.questions, ids[i])
		m.removedquestions[ids[i]] = struct{}{}
	}
}

// RemovedQuestions returns the removed IDs of the "questions" edge to the Question entity.
func (m *UserMutation) RemovedQuestionsIDs() (ids []int) {
	for id := range m.removedquestions {
		ids = append(ids, id)
	}
	return
}

// QuestionsIDs returns the "questions" edge IDs in the mutation.
func (m *UserMutation) QuestionsIDs() (ids []int) {
	for id := range m.questions {
		ids = append(ids, id)
	}
	return
}

// ResetQuestions resets all changes to the "questions" edge.
func (m *UserMutation) ResetQuestions() {
	m.questions = nil
	m.clearedquestions = false
	m.removedquestions = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddLikePostIDs adds the "like_posts" edge to the UserLikePost entity by ids.
func (m *UserMutation) AddLikePostIDs(ids ...int) {
	if m.like_posts == nil {
		m.like_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.like_posts[ids[i]] = struct{}{}
	}
}

// ClearLikePosts clears the "like_posts" edge to the UserLikePost entity.
func (m *UserMutation) ClearLikePosts() {
	m.clearedlike_posts = true
}

// LikePostsCleared reports if the "like_posts" edge to the UserLikePost entity was cleared.
func (m *UserMutation) LikePostsCleared() bool {
	return m.clearedlike_posts
}

// RemoveLikePostIDs removes the "like_posts" edge to the UserLikePost entity by IDs.
func (m *UserMutation) RemoveLikePostIDs(ids ...int) {
	if m.removedlike_posts == nil {
		m.removedlike_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.like_posts, ids[i])
		m.removedlike_posts[ids[i]] = struct{}{}
	}
}

// RemovedLikePosts returns the removed IDs of the "like_posts" edge to the UserLikePost entity.
func (m *UserMutation) RemovedLikePostsIDs() (ids []int) {
	for id := range m.removedlike_posts {
		ids = append(ids, id)
	}
	return
}

// LikePostsIDs returns the "like_posts" edge IDs in the mutation.
func (m *UserMutation) LikePostsIDs() (ids []int) {
	for id := range m.like_posts {
		ids = append(ids, id)
	}
	return
}

// ResetLikePosts resets all changes to the "like_posts" edge.
func (m *UserMutation) ResetLikePosts() {
	m.like_posts = nil
	m.clearedlike_posts = false
	m.removedlike_posts = nil
}

// AddLikeQuestionIDs adds the "like_questions" edge to the UserLikeQuestion entity by ids.
func (m *UserMutation) AddLikeQuestionIDs(ids ...int) {
	if m.like_questions == nil {
		m.like_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.like_questions[ids[i]] = struct{}{}
	}
}

// ClearLikeQuestions clears the "like_questions" edge to the UserLikeQuestion entity.
func (m *UserMutation) ClearLikeQuestions() {
	m.clearedlike_questions = true
}

// LikeQuestionsCleared reports if the "like_questions" edge to the UserLikeQuestion entity was cleared.
func (m *UserMutation) LikeQuestionsCleared() bool {
	return m.clearedlike_questions
}

// RemoveLikeQuestionIDs removes the "like_questions" edge to the UserLikeQuestion entity by IDs.
func (m *UserMutation) RemoveLikeQuestionIDs(ids ...int) {
	if m.removedlike_questions == nil {
		m.removedlike_questions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.like_questions, ids[i])
		m.removedlike_questions[ids[i]] = struct{}{}
	}
}

// RemovedLikeQuestions returns the removed IDs of the "like_questions" edge to the UserLikeQuestion entity.
func (m *UserMutation) RemovedLikeQuestionsIDs() (ids []int) {
	for id := range m.removedlike_questions {
		ids = append(ids, id)
	}
	return
}

// LikeQuestionsIDs returns the "like_questions" edge IDs in the mutation.
func (m *UserMutation) LikeQuestionsIDs() (ids []int) {
	for id := range m.like_questions {
		ids = append(ids, id)
	}
	return
}

// ResetLikeQuestions resets all changes to the "like_questions" edge.
func (m *UserMutation) ResetLikeQuestions() {
	m.like_questions = nil
	m.clearedlike_questions = false
	m.removedlike_questions = nil
}

// AddFavoritePostIDs adds the "favorite_posts" edge to the UserFavoritePost entity by ids.
func (m *UserMutation) AddFavoritePostIDs(ids ...int) {
	if m.favorite_posts == nil {
		m.favorite_posts = make(map[int]struct{})
	}
	for i := range ids {
		m.favorite_posts[ids[i]] = struct{}{}
	}
}

// ClearFavoritePosts clears the "favorite_posts" edge to the UserFavoritePost entity.
func (m *UserMutation) ClearFavoritePosts() {
	m.clearedfavorite_posts = true
}

// FavoritePostsCleared reports if the "favorite_posts" edge to the UserFavoritePost entity was cleared.
func (m *UserMutation) FavoritePostsCleared() bool {
	return m.clearedfavorite_posts
}

// RemoveFavoritePostIDs removes the "favorite_posts" edge to the UserFavoritePost entity by IDs.
func (m *UserMutation) RemoveFavoritePostIDs(ids ...int) {
	if m.removedfavorite_posts == nil {
		m.removedfavorite_posts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorite_posts, ids[i])
		m.removedfavorite_posts[ids[i]] = struct{}{}
	}
}

// RemovedFavoritePosts returns the removed IDs of the "favorite_posts" edge to the UserFavoritePost entity.
func (m *UserMutation) RemovedFavoritePostsIDs() (ids []int) {
	for id := range m.removedfavorite_posts {
		ids = append(ids, id)
	}
	return
}

// FavoritePostsIDs returns the "favorite_posts" edge IDs in the mutation.
func (m *UserMutation) FavoritePostsIDs() (ids []int) {
	for id := range m.favorite_posts {
		ids = append(ids, id)
	}
	return
}

// ResetFavoritePosts resets all changes to the "favorite_posts" edge.
func (m *UserMutation) ResetFavoritePosts() {
	m.favorite_posts = nil
	m.clearedfavorite_posts = false
	m.removedfavorite_posts = nil
}

// AddFavoriteQuestionIDs adds the "favorite_questions" edge to the UserFavoriteQuestion entity by ids.
func (m *UserMutation) AddFavoriteQuestionIDs(ids ...int) {
	if m.favorite_questions == nil {
		m.favorite_questions = make(map[int]struct{})
	}
	for i := range ids {
		m.favorite_questions[ids[i]] = struct{}{}
	}
}

// ClearFavoriteQuestions clears the "favorite_questions" edge to the UserFavoriteQuestion entity.
func (m *UserMutation) ClearFavoriteQuestions() {
	m.clearedfavorite_questions = true
}

// FavoriteQuestionsCleared reports if the "favorite_questions" edge to the UserFavoriteQuestion entity was cleared.
func (m *UserMutation) FavoriteQuestionsCleared() bool {
	return m.clearedfavorite_questions
}

// RemoveFavoriteQuestionIDs removes the "favorite_questions" edge to the UserFavoriteQuestion entity by IDs.
func (m *UserMutation) RemoveFavoriteQuestionIDs(ids ...int) {
	if m.removedfavorite_questions == nil {
		m.removedfavorite_questions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorite_questions, ids[i])
		m.removedfavorite_questions[ids[i]] = struct{}{}
	}
}

// RemovedFavoriteQuestions returns the removed IDs of the "favorite_questions" edge to the UserFavoriteQuestion entity.
func (m *UserMutation) RemovedFavoriteQuestionsIDs() (ids []int) {
	for id := range m.removedfavorite_questions {
		ids = append(ids, id)
	}
	return
}

// FavoriteQuestionsIDs returns the "favorite_questions" edge IDs in the mutation.
func (m *UserMutation) FavoriteQuestionsIDs() (ids []int) {
	for id := range m.favorite_questions {
		ids = append(ids, id)
	}
	return
}

// ResetFavoriteQuestions resets all changes to the "favorite_questions" edge.
func (m *UserMutation) ResetFavoriteQuestions() {
	m.favorite_questions = nil
	m.clearedfavorite_questions = false
	m.removedfavorite_questions = nil
}

// AddFollowingIDs adds the "following" edge to the Follow entity by ids.
func (m *UserMutation) AddFollowingIDs(ids ...int) {
	if m.following == nil {
		m.following = make(map[int]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the "following" edge to the Follow entity.
func (m *UserMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared reports if the "following" edge to the Follow entity was cleared.
func (m *UserMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the "following" edge to the Follow entity by IDs.
func (m *UserMutation) RemoveFollowingIDs(ids ...int) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.following, ids[i])
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed IDs of the "following" edge to the Follow entity.
func (m *UserMutation) RemovedFollowingIDs() (ids []int) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the "following" edge IDs in the mutation.
func (m *UserMutation) FollowingIDs() (ids []int) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing resets all changes to the "following" edge.
func (m *UserMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddFollowedByIDs adds the "followed_by" edge to the Follow entity by ids.
func (m *UserMutation) AddFollowedByIDs(ids ...int) {
	if m.followed_by == nil {
		m.followed_by = make(map[int]struct{})
	}
	for i := range ids {
		m.followed_by[ids[i]] = struct{}{}
	}
}

// ClearFollowedBy clears the "followed_by" edge to the Follow entity.
func (m *UserMutation) ClearFollowedBy() {
	m.clearedfollowed_by = true
}

// FollowedByCleared reports if the "followed_by" edge to the Follow entity was cleared.
func (m *UserMutation) FollowedByCleared() bool {
	return m.clearedfollowed_by
}

// RemoveFollowedByIDs removes the "followed_by" edge to the Follow entity by IDs.
func (m *UserMutation) RemoveFollowedByIDs(ids ...int) {
	if m.removedfollowed_by == nil {
		m.removedfollowed_by = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.followed_by, ids[i])
		m.removedfollowed_by[ids[i]] = struct{}{}
	}
}

// RemovedFollowedBy returns the removed IDs of the "followed_by" edge to the Follow entity.
func (m *UserMutation) RemovedFollowedByIDs() (ids []int) {
	for id := range m.removedfollowed_by {
		ids = append(ids, id)
	}
	return
}

// FollowedByIDs returns the "followed_by" edge IDs in the mutation.
func (m *UserMutation) FollowedByIDs() (ids []int) {
	for id := range m.followed_by {
		ids = append(ids, id)
	}
	return
}

// ResetFollowedBy resets all changes to the "followed_by" edge.
func (m *UserMutation) ResetFollowedBy() {
	m.followed_by = nil
	m.clearedfollowed_by = false
	m.removedfollowed_by = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldPassword:
		return m.Password()
	case user.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldNickname) {
		fields = append(fields, user.FieldNickname)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ClearNickname()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.posts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.questions != nil {
		edges = append(edges, user.EdgeQuestions)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.like_posts != nil {
		edges = append(edges, user.EdgeLikePosts)
	}
	if m.like_questions != nil {
		edges = append(edges, user.EdgeLikeQuestions)
	}
	if m.favorite_posts != nil {
		edges = append(edges, user.EdgeFavoritePosts)
	}
	if m.favorite_questions != nil {
		edges = append(edges, user.EdgeFavoriteQuestions)
	}
	if m.following != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.followed_by != nil {
		edges = append(edges, user.EdgeFollowedBy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.questions))
		for id := range m.questions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikePosts:
		ids := make([]ent.Value, 0, len(m.like_posts))
		for id := range m.like_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikeQuestions:
		ids := make([]ent.Value, 0, len(m.like_questions))
		for id := range m.like_questions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavoritePosts:
		ids := make([]ent.Value, 0, len(m.favorite_posts))
		for id := range m.favorite_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavoriteQuestions:
		ids := make([]ent.Value, 0, len(m.favorite_questions))
		for id := range m.favorite_questions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.followed_by))
		for id := range m.followed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedposts != nil {
		edges = append(edges, user.EdgePosts)
	}
	if m.removedquestions != nil {
		edges = append(edges, user.EdgeQuestions)
	}
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedlike_posts != nil {
		edges = append(edges, user.EdgeLikePosts)
	}
	if m.removedlike_questions != nil {
		edges = append(edges, user.EdgeLikeQuestions)
	}
	if m.removedfavorite_posts != nil {
		edges = append(edges, user.EdgeFavoritePosts)
	}
	if m.removedfavorite_questions != nil {
		edges = append(edges, user.EdgeFavoriteQuestions)
	}
	if m.removedfollowing != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.removedfollowed_by != nil {
		edges = append(edges, user.EdgeFollowedBy)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeQuestions:
		ids := make([]ent.Value, 0, len(m.removedquestions))
		for id := range m.removedquestions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikePosts:
		ids := make([]ent.Value, 0, len(m.removedlike_posts))
		for id := range m.removedlike_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikeQuestions:
		ids := make([]ent.Value, 0, len(m.removedlike_questions))
		for id := range m.removedlike_questions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavoritePosts:
		ids := make([]ent.Value, 0, len(m.removedfavorite_posts))
		for id := range m.removedfavorite_posts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFavoriteQuestions:
		ids := make([]ent.Value, 0, len(m.removedfavorite_questions))
		for id := range m.removedfavorite_questions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowedBy:
		ids := make([]ent.Value, 0, len(m.removedfollowed_by))
		for id := range m.removedfollowed_by {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedposts {
		edges = append(edges, user.EdgePosts)
	}
	if m.clearedquestions {
		edges = append(edges, user.EdgeQuestions)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedlike_posts {
		edges = append(edges, user.EdgeLikePosts)
	}
	if m.clearedlike_questions {
		edges = append(edges, user.EdgeLikeQuestions)
	}
	if m.clearedfavorite_posts {
		edges = append(edges, user.EdgeFavoritePosts)
	}
	if m.clearedfavorite_questions {
		edges = append(edges, user.EdgeFavoriteQuestions)
	}
	if m.clearedfollowing {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.clearedfollowed_by {
		edges = append(edges, user.EdgeFollowedBy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgePosts:
		return m.clearedposts
	case user.EdgeQuestions:
		return m.clearedquestions
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeLikePosts:
		return m.clearedlike_posts
	case user.EdgeLikeQuestions:
		return m.clearedlike_questions
	case user.EdgeFavoritePosts:
		return m.clearedfavorite_posts
	case user.EdgeFavoriteQuestions:
		return m.clearedfavorite_questions
	case user.EdgeFollowing:
		return m.clearedfollowing
	case user.EdgeFollowedBy:
		return m.clearedfollowed_by
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgePosts:
		m.ResetPosts()
		return nil
	case user.EdgeQuestions:
		m.ResetQuestions()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeLikePosts:
		m.ResetLikePosts()
		return nil
	case user.EdgeLikeQuestions:
		m.ResetLikeQuestions()
		return nil
	case user.EdgeFavoritePosts:
		m.ResetFavoritePosts()
		return nil
	case user.EdgeFavoriteQuestions:
		m.ResetFavoriteQuestions()
		return nil
	case user.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case user.EdgeFollowedBy:
		m.ResetFollowedBy()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserFavoritePostMutation represents an operation that mutates the UserFavoritePost nodes in the graph.
type UserFavoritePostMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	post_id       *int
	addpost_id    *int
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	post          map[int]struct{}
	removedpost   map[int]struct{}
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*UserFavoritePost, error)
	predicates    []predicate.UserFavoritePost
}

var _ ent.Mutation = (*UserFavoritePostMutation)(nil)

// userfavoritepostOption allows management of the mutation configuration using functional options.
type userfavoritepostOption func(*UserFavoritePostMutation)

// newUserFavoritePostMutation creates new mutation for the UserFavoritePost entity.
func newUserFavoritePostMutation(c config, op Op, opts ...userfavoritepostOption) *UserFavoritePostMutation {
	m := &UserFavoritePostMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavoritePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavoritePostID sets the ID field of the mutation.
func withUserFavoritePostID(id int) userfavoritepostOption {
	return func(m *UserFavoritePostMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavoritePost
		)
		m.oldValue = func(ctx context.Context) (*UserFavoritePost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavoritePost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavoritePost sets the old UserFavoritePost of the mutation.
func withUserFavoritePost(node *UserFavoritePost) userfavoritepostOption {
	return func(m *UserFavoritePostMutation) {
		m.oldValue = func(context.Context) (*UserFavoritePost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavoritePostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavoritePostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavoritePostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFavoritePostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFavoritePost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserFavoritePostMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavoritePostMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavoritePost entity.
// If the UserFavoritePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoritePostMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserFavoritePostMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserFavoritePostMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavoritePostMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPostID sets the "post_id" field.
func (m *UserFavoritePostMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *UserFavoritePostMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the UserFavoritePost entity.
// If the UserFavoritePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoritePostMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *UserFavoritePostMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *UserFavoritePostMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *UserFavoritePostMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserFavoritePostMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFavoritePostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFavoritePostMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserFavoritePostMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserFavoritePostMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserFavoritePostMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFavoritePostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddPostIDs adds the "post" edge to the Post entity by ids.
func (m *UserFavoritePostMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the Post entity.
func (m *UserFavoritePostMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *UserFavoritePostMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the Post entity by IDs.
func (m *UserFavoritePostMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the Post entity.
func (m *UserFavoritePostMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *UserFavoritePostMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *UserFavoritePostMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// Where appends a list predicates to the UserFavoritePostMutation builder.
func (m *UserFavoritePostMutation) Where(ps ...predicate.UserFavoritePost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFavoritePostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFavoritePostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFavoritePost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFavoritePostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFavoritePostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFavoritePost).
func (m *UserFavoritePostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavoritePostMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user_id != nil {
		fields = append(fields, userfavoritepost.FieldUserID)
	}
	if m.post_id != nil {
		fields = append(fields, userfavoritepost.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavoritePostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavoritepost.FieldUserID:
		return m.UserID()
	case userfavoritepost.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavoritePostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavoritepost.FieldUserID:
		return m.OldUserID(ctx)
	case userfavoritepost.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavoritePost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoritePostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavoritepost.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfavoritepost.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavoritePost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavoritePostMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userfavoritepost.FieldUserID)
	}
	if m.addpost_id != nil {
		fields = append(fields, userfavoritepost.FieldPostID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavoritePostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfavoritepost.FieldUserID:
		return m.AddedUserID()
	case userfavoritepost.FieldPostID:
		return m.AddedPostID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoritePostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfavoritepost.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userfavoritepost.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavoritePost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavoritePostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavoritePostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavoritePostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFavoritePost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavoritePostMutation) ResetField(name string) error {
	switch name {
	case userfavoritepost.FieldUserID:
		m.ResetUserID()
		return nil
	case userfavoritepost.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown UserFavoritePost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavoritePostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfavoritepost.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, userfavoritepost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavoritePostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfavoritepost.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case userfavoritepost.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavoritePostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userfavoritepost.EdgeUser)
	}
	if m.removedpost != nil {
		edges = append(edges, userfavoritepost.EdgePost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavoritePostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userfavoritepost.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case userfavoritepost.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavoritePostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfavoritepost.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, userfavoritepost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavoritePostMutation) EdgeCleared(name string) bool {
	switch name {
	case userfavoritepost.EdgeUser:
		return m.cleareduser
	case userfavoritepost.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavoritePostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFavoritePost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavoritePostMutation) ResetEdge(name string) error {
	switch name {
	case userfavoritepost.EdgeUser:
		m.ResetUser()
		return nil
	case userfavoritepost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown UserFavoritePost edge %s", name)
}

// UserFavoriteQuestionMutation represents an operation that mutates the UserFavoriteQuestion nodes in the graph.
type UserFavoriteQuestionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *int
	adduser_id      *int
	question_id     *int
	addquestion_id  *int
	clearedFields   map[string]struct{}
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	question        map[int]struct{}
	removedquestion map[int]struct{}
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*UserFavoriteQuestion, error)
	predicates      []predicate.UserFavoriteQuestion
}

var _ ent.Mutation = (*UserFavoriteQuestionMutation)(nil)

// userfavoritequestionOption allows management of the mutation configuration using functional options.
type userfavoritequestionOption func(*UserFavoriteQuestionMutation)

// newUserFavoriteQuestionMutation creates new mutation for the UserFavoriteQuestion entity.
func newUserFavoriteQuestionMutation(c config, op Op, opts ...userfavoritequestionOption) *UserFavoriteQuestionMutation {
	m := &UserFavoriteQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavoriteQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavoriteQuestionID sets the ID field of the mutation.
func withUserFavoriteQuestionID(id int) userfavoritequestionOption {
	return func(m *UserFavoriteQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavoriteQuestion
		)
		m.oldValue = func(ctx context.Context) (*UserFavoriteQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavoriteQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavoriteQuestion sets the old UserFavoriteQuestion of the mutation.
func withUserFavoriteQuestion(node *UserFavoriteQuestion) userfavoritequestionOption {
	return func(m *UserFavoriteQuestionMutation) {
		m.oldValue = func(context.Context) (*UserFavoriteQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavoriteQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavoriteQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavoriteQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFavoriteQuestionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFavoriteQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserFavoriteQuestionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavoriteQuestionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavoriteQuestion entity.
// If the UserFavoriteQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteQuestionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserFavoriteQuestionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserFavoriteQuestionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavoriteQuestionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetQuestionID sets the "question_id" field.
func (m *UserFavoriteQuestionMutation) SetQuestionID(i int) {
	m.question_id = &i
	m.addquestion_id = nil
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *UserFavoriteQuestionMutation) QuestionID() (r int, exists bool) {
	v := m.question_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the UserFavoriteQuestion entity.
// If the UserFavoriteQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteQuestionMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// AddQuestionID adds i to the "question_id" field.
func (m *UserFavoriteQuestionMutation) AddQuestionID(i int) {
	if m.addquestion_id != nil {
		*m.addquestion_id += i
	} else {
		m.addquestion_id = &i
	}
}

// AddedQuestionID returns the value that was added to the "question_id" field in this mutation.
func (m *UserFavoriteQuestionMutation) AddedQuestionID() (r int, exists bool) {
	v := m.addquestion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *UserFavoriteQuestionMutation) ResetQuestionID() {
	m.question_id = nil
	m.addquestion_id = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserFavoriteQuestionMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFavoriteQuestionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFavoriteQuestionMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserFavoriteQuestionMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserFavoriteQuestionMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserFavoriteQuestionMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFavoriteQuestionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddQuestionIDs adds the "question" edge to the Question entity by ids.
func (m *UserFavoriteQuestionMutation) AddQuestionIDs(ids ...int) {
	if m.question == nil {
		m.question = make(map[int]struct{})
	}
	for i := range ids {
		m.question[ids[i]] = struct{}{}
	}
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *UserFavoriteQuestionMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *UserFavoriteQuestionMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// RemoveQuestionIDs removes the "question" edge to the Question entity by IDs.
func (m *UserFavoriteQuestionMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestion == nil {
		m.removedquestion = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question, ids[i])
		m.removedquestion[ids[i]] = struct{}{}
	}
}

// RemovedQuestion returns the removed IDs of the "question" edge to the Question entity.
func (m *UserFavoriteQuestionMutation) RemovedQuestionIDs() (ids []int) {
	for id := range m.removedquestion {
		ids = append(ids, id)
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
func (m *UserFavoriteQuestionMutation) QuestionIDs() (ids []int) {
	for id := range m.question {
		ids = append(ids, id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *UserFavoriteQuestionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
	m.removedquestion = nil
}

// Where appends a list predicates to the UserFavoriteQuestionMutation builder.
func (m *UserFavoriteQuestionMutation) Where(ps ...predicate.UserFavoriteQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFavoriteQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFavoriteQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFavoriteQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFavoriteQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFavoriteQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFavoriteQuestion).
func (m *UserFavoriteQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavoriteQuestionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user_id != nil {
		fields = append(fields, userfavoritequestion.FieldUserID)
	}
	if m.question_id != nil {
		fields = append(fields, userfavoritequestion.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavoriteQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavoritequestion.FieldUserID:
		return m.UserID()
	case userfavoritequestion.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavoriteQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavoritequestion.FieldUserID:
		return m.OldUserID(ctx)
	case userfavoritequestion.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavoriteQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavoritequestion.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfavoritequestion.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavoriteQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavoriteQuestionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userfavoritequestion.FieldUserID)
	}
	if m.addquestion_id != nil {
		fields = append(fields, userfavoritequestion.FieldQuestionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavoriteQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfavoritequestion.FieldUserID:
		return m.AddedUserID()
	case userfavoritequestion.FieldQuestionID:
		return m.AddedQuestionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfavoritequestion.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userfavoritequestion.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavoriteQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavoriteQuestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavoriteQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavoriteQuestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFavoriteQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavoriteQuestionMutation) ResetField(name string) error {
	switch name {
	case userfavoritequestion.FieldUserID:
		m.ResetUserID()
		return nil
	case userfavoritequestion.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown UserFavoriteQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavoriteQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userfavoritequestion.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, userfavoritequestion.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavoriteQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfavoritequestion.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case userfavoritequestion.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.question))
		for id := range m.question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavoriteQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userfavoritequestion.EdgeUser)
	}
	if m.removedquestion != nil {
		edges = append(edges, userfavoritequestion.EdgeQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavoriteQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userfavoritequestion.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case userfavoritequestion.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.removedquestion))
		for id := range m.removedquestion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavoriteQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userfavoritequestion.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, userfavoritequestion.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavoriteQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case userfavoritequestion.EdgeUser:
		return m.cleareduser
	case userfavoritequestion.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavoriteQuestionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFavoriteQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavoriteQuestionMutation) ResetEdge(name string) error {
	switch name {
	case userfavoritequestion.EdgeUser:
		m.ResetUser()
		return nil
	case userfavoritequestion.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown UserFavoriteQuestion edge %s", name)
}

// UserLikePostMutation represents an operation that mutates the UserLikePost nodes in the graph.
type UserLikePostMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *int
	adduser_id    *int
	post_id       *int
	addpost_id    *int
	clearedFields map[string]struct{}
	user          map[int]struct{}
	removeduser   map[int]struct{}
	cleareduser   bool
	post          map[int]struct{}
	removedpost   map[int]struct{}
	clearedpost   bool
	done          bool
	oldValue      func(context.Context) (*UserLikePost, error)
	predicates    []predicate.UserLikePost
}

var _ ent.Mutation = (*UserLikePostMutation)(nil)

// userlikepostOption allows management of the mutation configuration using functional options.
type userlikepostOption func(*UserLikePostMutation)

// newUserLikePostMutation creates new mutation for the UserLikePost entity.
func newUserLikePostMutation(c config, op Op, opts ...userlikepostOption) *UserLikePostMutation {
	m := &UserLikePostMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLikePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLikePostID sets the ID field of the mutation.
func withUserLikePostID(id int) userlikepostOption {
	return func(m *UserLikePostMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLikePost
		)
		m.oldValue = func(ctx context.Context) (*UserLikePost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLikePost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLikePost sets the old UserLikePost of the mutation.
func withUserLikePost(node *UserLikePost) userlikepostOption {
	return func(m *UserLikePostMutation) {
		m.oldValue = func(context.Context) (*UserLikePost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLikePostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLikePostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLikePostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLikePostMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLikePost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserLikePostMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLikePostMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLikePost entity.
// If the UserLikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikePostMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserLikePostMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserLikePostMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLikePostMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPostID sets the "post_id" field.
func (m *UserLikePostMutation) SetPostID(i int) {
	m.post_id = &i
	m.addpost_id = nil
}

// PostID returns the value of the "post_id" field in the mutation.
func (m *UserLikePostMutation) PostID() (r int, exists bool) {
	v := m.post_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostID returns the old "post_id" field's value of the UserLikePost entity.
// If the UserLikePost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikePostMutation) OldPostID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostID: %w", err)
	}
	return oldValue.PostID, nil
}

// AddPostID adds i to the "post_id" field.
func (m *UserLikePostMutation) AddPostID(i int) {
	if m.addpost_id != nil {
		*m.addpost_id += i
	} else {
		m.addpost_id = &i
	}
}

// AddedPostID returns the value that was added to the "post_id" field in this mutation.
func (m *UserLikePostMutation) AddedPostID() (r int, exists bool) {
	v := m.addpost_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPostID resets all changes to the "post_id" field.
func (m *UserLikePostMutation) ResetPostID() {
	m.post_id = nil
	m.addpost_id = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserLikePostMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLikePostMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLikePostMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserLikePostMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserLikePostMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserLikePostMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLikePostMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddPostIDs adds the "post" edge to the Post entity by ids.
func (m *UserLikePostMutation) AddPostIDs(ids ...int) {
	if m.post == nil {
		m.post = make(map[int]struct{})
	}
	for i := range ids {
		m.post[ids[i]] = struct{}{}
	}
}

// ClearPost clears the "post" edge to the Post entity.
func (m *UserLikePostMutation) ClearPost() {
	m.clearedpost = true
}

// PostCleared reports if the "post" edge to the Post entity was cleared.
func (m *UserLikePostMutation) PostCleared() bool {
	return m.clearedpost
}

// RemovePostIDs removes the "post" edge to the Post entity by IDs.
func (m *UserLikePostMutation) RemovePostIDs(ids ...int) {
	if m.removedpost == nil {
		m.removedpost = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.post, ids[i])
		m.removedpost[ids[i]] = struct{}{}
	}
}

// RemovedPost returns the removed IDs of the "post" edge to the Post entity.
func (m *UserLikePostMutation) RemovedPostIDs() (ids []int) {
	for id := range m.removedpost {
		ids = append(ids, id)
	}
	return
}

// PostIDs returns the "post" edge IDs in the mutation.
func (m *UserLikePostMutation) PostIDs() (ids []int) {
	for id := range m.post {
		ids = append(ids, id)
	}
	return
}

// ResetPost resets all changes to the "post" edge.
func (m *UserLikePostMutation) ResetPost() {
	m.post = nil
	m.clearedpost = false
	m.removedpost = nil
}

// Where appends a list predicates to the UserLikePostMutation builder.
func (m *UserLikePostMutation) Where(ps ...predicate.UserLikePost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLikePostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLikePostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLikePost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLikePostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLikePostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLikePost).
func (m *UserLikePostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLikePostMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user_id != nil {
		fields = append(fields, userlikepost.FieldUserID)
	}
	if m.post_id != nil {
		fields = append(fields, userlikepost.FieldPostID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLikePostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlikepost.FieldUserID:
		return m.UserID()
	case userlikepost.FieldPostID:
		return m.PostID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLikePostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlikepost.FieldUserID:
		return m.OldUserID(ctx)
	case userlikepost.FieldPostID:
		return m.OldPostID(ctx)
	}
	return nil, fmt.Errorf("unknown UserLikePost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikePostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlikepost.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userlikepost.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostID(v)
		return nil
	}
	return fmt.Errorf("unknown UserLikePost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLikePostMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userlikepost.FieldUserID)
	}
	if m.addpost_id != nil {
		fields = append(fields, userlikepost.FieldPostID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLikePostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userlikepost.FieldUserID:
		return m.AddedUserID()
	case userlikepost.FieldPostID:
		return m.AddedPostID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikePostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userlikepost.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userlikepost.FieldPostID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostID(v)
		return nil
	}
	return fmt.Errorf("unknown UserLikePost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLikePostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLikePostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLikePostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserLikePost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLikePostMutation) ResetField(name string) error {
	switch name {
	case userlikepost.FieldUserID:
		m.ResetUserID()
		return nil
	case userlikepost.FieldPostID:
		m.ResetPostID()
		return nil
	}
	return fmt.Errorf("unknown UserLikePost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLikePostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userlikepost.EdgeUser)
	}
	if m.post != nil {
		edges = append(edges, userlikepost.EdgePost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLikePostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlikepost.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case userlikepost.EdgePost:
		ids := make([]ent.Value, 0, len(m.post))
		for id := range m.post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLikePostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userlikepost.EdgeUser)
	}
	if m.removedpost != nil {
		edges = append(edges, userlikepost.EdgePost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLikePostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userlikepost.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case userlikepost.EdgePost:
		ids := make([]ent.Value, 0, len(m.removedpost))
		for id := range m.removedpost {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLikePostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userlikepost.EdgeUser)
	}
	if m.clearedpost {
		edges = append(edges, userlikepost.EdgePost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLikePostMutation) EdgeCleared(name string) bool {
	switch name {
	case userlikepost.EdgeUser:
		return m.cleareduser
	case userlikepost.EdgePost:
		return m.clearedpost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLikePostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLikePost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLikePostMutation) ResetEdge(name string) error {
	switch name {
	case userlikepost.EdgeUser:
		m.ResetUser()
		return nil
	case userlikepost.EdgePost:
		m.ResetPost()
		return nil
	}
	return fmt.Errorf("unknown UserLikePost edge %s", name)
}

// UserLikeQuestionMutation represents an operation that mutates the UserLikeQuestion nodes in the graph.
type UserLikeQuestionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *int
	adduser_id      *int
	question_id     *int
	addquestion_id  *int
	clearedFields   map[string]struct{}
	user            map[int]struct{}
	removeduser     map[int]struct{}
	cleareduser     bool
	question        map[int]struct{}
	removedquestion map[int]struct{}
	clearedquestion bool
	done            bool
	oldValue        func(context.Context) (*UserLikeQuestion, error)
	predicates      []predicate.UserLikeQuestion
}

var _ ent.Mutation = (*UserLikeQuestionMutation)(nil)

// userlikequestionOption allows management of the mutation configuration using functional options.
type userlikequestionOption func(*UserLikeQuestionMutation)

// newUserLikeQuestionMutation creates new mutation for the UserLikeQuestion entity.
func newUserLikeQuestionMutation(c config, op Op, opts ...userlikequestionOption) *UserLikeQuestionMutation {
	m := &UserLikeQuestionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserLikeQuestion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserLikeQuestionID sets the ID field of the mutation.
func withUserLikeQuestionID(id int) userlikequestionOption {
	return func(m *UserLikeQuestionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserLikeQuestion
		)
		m.oldValue = func(ctx context.Context) (*UserLikeQuestion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserLikeQuestion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserLikeQuestion sets the old UserLikeQuestion of the mutation.
func withUserLikeQuestion(node *UserLikeQuestion) userlikequestionOption {
	return func(m *UserLikeQuestionMutation) {
		m.oldValue = func(context.Context) (*UserLikeQuestion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserLikeQuestionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserLikeQuestionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserLikeQuestionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserLikeQuestionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserLikeQuestion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserLikeQuestionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserLikeQuestionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserLikeQuestion entity.
// If the UserLikeQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikeQuestionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserLikeQuestionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserLikeQuestionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserLikeQuestionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetQuestionID sets the "question_id" field.
func (m *UserLikeQuestionMutation) SetQuestionID(i int) {
	m.question_id = &i
	m.addquestion_id = nil
}

// QuestionID returns the value of the "question_id" field in the mutation.
func (m *UserLikeQuestionMutation) QuestionID() (r int, exists bool) {
	v := m.question_id
	if v == nil {
		return
	}
	return *v, true
}

// OldQuestionID returns the old "question_id" field's value of the UserLikeQuestion entity.
// If the UserLikeQuestion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserLikeQuestionMutation) OldQuestionID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuestionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuestionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuestionID: %w", err)
	}
	return oldValue.QuestionID, nil
}

// AddQuestionID adds i to the "question_id" field.
func (m *UserLikeQuestionMutation) AddQuestionID(i int) {
	if m.addquestion_id != nil {
		*m.addquestion_id += i
	} else {
		m.addquestion_id = &i
	}
}

// AddedQuestionID returns the value that was added to the "question_id" field in this mutation.
func (m *UserLikeQuestionMutation) AddedQuestionID() (r int, exists bool) {
	v := m.addquestion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuestionID resets all changes to the "question_id" field.
func (m *UserLikeQuestionMutation) ResetQuestionID() {
	m.question_id = nil
	m.addquestion_id = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UserLikeQuestionMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserLikeQuestionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserLikeQuestionMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UserLikeQuestionMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UserLikeQuestionMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UserLikeQuestionMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserLikeQuestionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddQuestionIDs adds the "question" edge to the Question entity by ids.
func (m *UserLikeQuestionMutation) AddQuestionIDs(ids ...int) {
	if m.question == nil {
		m.question = make(map[int]struct{})
	}
	for i := range ids {
		m.question[ids[i]] = struct{}{}
	}
}

// ClearQuestion clears the "question" edge to the Question entity.
func (m *UserLikeQuestionMutation) ClearQuestion() {
	m.clearedquestion = true
}

// QuestionCleared reports if the "question" edge to the Question entity was cleared.
func (m *UserLikeQuestionMutation) QuestionCleared() bool {
	return m.clearedquestion
}

// RemoveQuestionIDs removes the "question" edge to the Question entity by IDs.
func (m *UserLikeQuestionMutation) RemoveQuestionIDs(ids ...int) {
	if m.removedquestion == nil {
		m.removedquestion = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.question, ids[i])
		m.removedquestion[ids[i]] = struct{}{}
	}
}

// RemovedQuestion returns the removed IDs of the "question" edge to the Question entity.
func (m *UserLikeQuestionMutation) RemovedQuestionIDs() (ids []int) {
	for id := range m.removedquestion {
		ids = append(ids, id)
	}
	return
}

// QuestionIDs returns the "question" edge IDs in the mutation.
func (m *UserLikeQuestionMutation) QuestionIDs() (ids []int) {
	for id := range m.question {
		ids = append(ids, id)
	}
	return
}

// ResetQuestion resets all changes to the "question" edge.
func (m *UserLikeQuestionMutation) ResetQuestion() {
	m.question = nil
	m.clearedquestion = false
	m.removedquestion = nil
}

// Where appends a list predicates to the UserLikeQuestionMutation builder.
func (m *UserLikeQuestionMutation) Where(ps ...predicate.UserLikeQuestion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserLikeQuestionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserLikeQuestionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserLikeQuestion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserLikeQuestionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserLikeQuestionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserLikeQuestion).
func (m *UserLikeQuestionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserLikeQuestionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.user_id != nil {
		fields = append(fields, userlikequestion.FieldUserID)
	}
	if m.question_id != nil {
		fields = append(fields, userlikequestion.FieldQuestionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserLikeQuestionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userlikequestion.FieldUserID:
		return m.UserID()
	case userlikequestion.FieldQuestionID:
		return m.QuestionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserLikeQuestionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userlikequestion.FieldUserID:
		return m.OldUserID(ctx)
	case userlikequestion.FieldQuestionID:
		return m.OldQuestionID(ctx)
	}
	return nil, fmt.Errorf("unknown UserLikeQuestion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikeQuestionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userlikequestion.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userlikequestion.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown UserLikeQuestion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserLikeQuestionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userlikequestion.FieldUserID)
	}
	if m.addquestion_id != nil {
		fields = append(fields, userlikequestion.FieldQuestionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserLikeQuestionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userlikequestion.FieldUserID:
		return m.AddedUserID()
	case userlikequestion.FieldQuestionID:
		return m.AddedQuestionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserLikeQuestionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userlikequestion.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userlikequestion.FieldQuestionID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuestionID(v)
		return nil
	}
	return fmt.Errorf("unknown UserLikeQuestion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserLikeQuestionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserLikeQuestionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserLikeQuestionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserLikeQuestion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserLikeQuestionMutation) ResetField(name string) error {
	switch name {
	case userlikequestion.FieldUserID:
		m.ResetUserID()
		return nil
	case userlikequestion.FieldQuestionID:
		m.ResetQuestionID()
		return nil
	}
	return fmt.Errorf("unknown UserLikeQuestion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserLikeQuestionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userlikequestion.EdgeUser)
	}
	if m.question != nil {
		edges = append(edges, userlikequestion.EdgeQuestion)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserLikeQuestionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userlikequestion.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case userlikequestion.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.question))
		for id := range m.question {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserLikeQuestionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, userlikequestion.EdgeUser)
	}
	if m.removedquestion != nil {
		edges = append(edges, userlikequestion.EdgeQuestion)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserLikeQuestionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userlikequestion.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case userlikequestion.EdgeQuestion:
		ids := make([]ent.Value, 0, len(m.removedquestion))
		for id := range m.removedquestion {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserLikeQuestionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userlikequestion.EdgeUser)
	}
	if m.clearedquestion {
		edges = append(edges, userlikequestion.EdgeQuestion)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserLikeQuestionMutation) EdgeCleared(name string) bool {
	switch name {
	case userlikequestion.EdgeUser:
		return m.cleareduser
	case userlikequestion.EdgeQuestion:
		return m.clearedquestion
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserLikeQuestionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserLikeQuestion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserLikeQuestionMutation) ResetEdge(name string) error {
	switch name {
	case userlikequestion.EdgeUser:
		m.ResetUser()
		return nil
	case userlikequestion.EdgeQuestion:
		m.ResetQuestion()
		return nil
	}
	return fmt.Errorf("unknown UserLikeQuestion edge %s", name)
}
